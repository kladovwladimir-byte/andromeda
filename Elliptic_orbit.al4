/*

//- ellipse is calculated for T=100_000 years, and M=1000_000 or Sun masses,
//- for a given Excentricity (between 0 and 1).
//! All other ellipses of the same excentricity are calculated from it
//! on fly by scaling correspondent points.
//[image: formulas.png]


CLASS {Elliptic_orbit}, UNTESTED:

IMPORT: {{Standard}}, {{Files}}, {{Visual}} .
IMPORT: {Main_plasma_tides} . //-> qq

REAL Excentric|ity, INIT, READ

CONST REAL : 
	G|ravitation_constant = 6.6743e-11
	Sun_mass = 1.98847e+30 				
	Mass_BH0|_standard = 1.98847e+36 //=Sun_mass * 1_000_000
	T0|_period_standard = 100_000.0
	LY|_Light_Year_in_meters = 9.46e+15
	YEAR|_seconds = 31_536_000.0
	.

STRUCTURE {e_point|_of_ellipse} :
    REAL X|_coordinate
    REAL Y|_coordinate
    REAL X_LY|_in_light_years
    REAL Y_LY|_in_light_years
    REAL R|_distance_to_focus 
    REAL T|ime_from_start_move_at_Apoholy
    REAL V|elocity 
    {point} Dir|ection|_vector_of_length_1
    .
    
{e_point} Points|_array[]  
REAL Q_min|imal_radius  
REAL Q_max|imal_radius 
    
CONSTRUCT:
	Points[].Allocate(360)
	REAL t|_parameter_radian = 0
	-------------------------------- 'a, b, Q_min, Q_max'
	REAL a|_big_semiaxis_Meters = G * Mass_BH0 * (T0 * YEAR).qq / 4 / PI.qq
	.. = _.Power(1/3.0) /// LY
	Q_min = a * (1 - Excentricity)
	Q_max = a * (1 + Excentricity) 
    //DEBUG: "{Elliptic_orbit}.a=" a #NL ;
	REAL b|_small_semiax = a * Sqrt(1 - Excentricity.qq)
	{e_point} prev|ious_point
	FOR i IN [0 TO Points[].Count-1] :
		{e_point} p|oint_of_i = {e_point}(
			X= a * (Cos(t) - Excentricity), Y= b * Sin(t),
			R= (a.qq * (Cos(t) - Excentricity).qq + b.qq * Sin(t).qq).Sqrt)
		----------------- 'in light years'	
		p.X_LY = p.X / LY
		p.Y_LY = p.Y / LY
		----------------- 'direction'
		REAL dist|ance_to_C = (p.X.qq + p.Y.qq).Sqrt
		p.Dir = Pt(p.X/dist, p.Y/dist)
		----------------- 'speed'
		p.V = (G * Mass_BH0 * (2/p.R - 1/a)).Sqrt
		CASE i > 0 ? 
			 REAL d|istance = ((p.X - prev.X).qq + (p.Y - prev.Y).qq).Sqrt     
		     p.T = prev.T + d / p.V 
		;
		Points[i] = p.CLONE
		//prev = p.CLONE
		prev...T = p.T
		...X = p.X
		...Y = p.Y
	    ---------------------------- 'next t'
	    t += 2 * PI / Points[].Count 
	; 
	FOR i IN [0 TO Points[].Count-1] :
	    Points[i].T /= YEAR
	    REAL last_time = Points[i].T 
	;
    //DEBUG: "T= "#TAB (T0) #NL"l_t="#TAB last_time " ***************" #NL ;
	.


END

*/
